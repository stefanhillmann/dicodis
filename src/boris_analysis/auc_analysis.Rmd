---
title: "AUC Analysis"
author: "Stefan Hillmann"
date: "6. Oktober 2015"
output: html_document
---


```{r}
  library(RMongo)
  library(ggplot2)
  library(plyr)
  library(reshape2)
  library(knitr)
```

Load data
```{r}
  cross_validation <- mongoDbConnect("classification_cross_validation", "localhost", 27017)
  performance <- dbGetQuery(cross_validation, "performance", '{}', 0, 0)
```

Filter just one half of the symmetric (regarding to AUC) data
```{r}
#   juged.data <- pr.complete[which(pr.complete$criteria %in% c('juged_bad', 'juged_good')), ]
#   interact_length.data <- pr.complete[which(pr.complete$criteria %in% c('short_interactions', 'long_interactions')), ]
#   real_simulated.data <- pr.complete[which(pr.complete$criteria %in% c('real', 'simulated')), ]
#   success.data <- pr.complete[which(pr.complete$criteria %in% c('task_failed', 'task_successful')), ]
#   word_accuracy.data <- pr.complete[which(pr.complete$criteria %in% c('word_accuracy_100', 'word_accuracy_60')), ]
#   simulation_quality.data <- pr.complete[which(pr.complete$criteria %in% c('simulation_quality_best', 'simulation_quality_worst')), ]
#   real_vs_worst_sim.data <- pr.complete[which(pr.complete$criteria %in% c('real_vs_simulated_worst', 'simulated_worst_vs_real')), ]
  
  cutted <- performance[performance$criteria=='juged_bad',]
  cutted <- rbind(cutted, performance[performance$criteria=='short_interactions',])
  cutted <- rbind(cutted, performance[performance$criteria=='real',])
  cutted <- rbind(cutted, performance[performance$criteria=='task_failed',])
  cutted <- rbind(cutted, performance[performance$criteria=='word_accuracy_100',])
  cutted <- rbind(cutted, performance[performance$criteria=='simulation_quality_best',])
  cutted <- rbind(cutted, performance[performance$criteria=='real_vs_simulated_worst',])
  
  # for rank order we need only one case for smoothing value, as the smoothing value is
  # not used for rank order
  # select all rows where criteria name is not "rank order" and smoothing_value is not in (0.05, 0.25)
  # That keeps all classifier != "rank order", and for "rank order" only those with smoothin_value == 0.5
  cutted <- cutted[which( !(cutted$classifier_name == "rank order" & cutted$smoothing_value %in% c(0.05, 0.25)) ), ]
  
  # Set names for criteria
  cutted$criteria_name <- 'NA'
  cutted[which(cutted$criteria == 'juged_bad'),]$criteria_name <- 'user jugedment'
  cutted[which(cutted$criteria == 'short_interactions'),]$criteria_name <- 'dialogue length'
  cutted[which(cutted$criteria == 'real'),]$criteria_name <- 'real vs sim. (good)'
  cutted[which(cutted$criteria == 'task_failed'),]$criteria_name <- 'task success'
  cutted[which(cutted$criteria == 'word_accuracy_100'),]$criteria_name <- 'word accuracy'
  cutted[which(cutted$criteria == 'simulation_quality_best'),]$criteria_name <- 'simulation quality'
  cutted[which(cutted$criteria == 'real_vs_simulated_worst'),]$criteria_name <- 'real vs. sim. (bad)'
```


# Overview #

Histogram of AUC for all `r nrow(performance)` scenarios.

```{r auc_histo_cutted, echo=FALSE}
  ggplot(cutted, aes(x = auc)) + 
    geom_histogram(aes(y=..density..), colour="black", fill="white", binwidth=0.01) +
    geom_density(alpha=.2, fill="#FF6666") + 
    geom_vline(aes(xintercept=mean(auc, na.rm=T)),
               color="red", linetype="dashed", size=1) + 
    geom_vline(aes(xintercept=median(auc, na.rm=T)),
               color="red", size=1)
```

Mean: `r mean(cutted$auc)`

Median: `r median(cutted$auc)`

## Distribution of AUC values per Distance Measure ##

```{r auc_per_measure, echo=FALSE, cache=TRUE}
  measures <- unique(cutted$classifier_name)
  for (i in 1:length(measures)) {
    m <- measures[i]
    print(
    ggplot(cutted[which(cutted$classifier_name == m),], aes(x = auc)) + 
    geom_histogram(aes(y=..density..), colour="black", fill="white", binwidth=0.01) +
    geom_density(alpha=.2, fill="#FF6666") + 
    geom_vline(aes(xintercept=mean(auc, na.rm=T)),
               color="red", linetype="dashed", size=1) + 
    geom_vline(aes(xintercept=median(auc, na.rm=T)),
               color="red", size=1) +
    ggtitle(m)
    )
  }
```

## AUC in dependency of measures and criteria ##

```{r}
  ggplot(cutted, aes(x=criteria_name, y=auc, color=classifier_name)) + geom_point() +
  theme(axis.text.x = element_text(angle=90))
```

## Rank Order ##

### AUC in dependency of n-gram size and criteria ###

```{r}
  ggplot(cutted[which(cutted$classifier_name == 'rank order'),], aes(x=criteria_name, y=auc, color=factor(n_gram_size))) +
  geom_point() +
  theme(axis.text.x = element_text(angle=90))
```

### AUC in dependency of frequency threshold and criteria ###

```{r}
  ggplot(cutted[which(cutted$classifier_name == 'rank order'),], aes(x=criteria_name, y=auc, color=factor(frequency_threshold))) +
  geom_point() +
  theme(axis.text.x = element_text(angle=90))
```

### AUC in dependency of frequency threshold and criteria ###

```{r}
  ggplot(cutted[which(cutted$classifier_name == 'rank order'),], aes(x=criteria_name, y=auc, color=factor(smoothing_value))) +
  geom_point() +
  theme(axis.text.x = element_text(angle=90))
```

# Details about different AUC, Scenarios, Measures #

## Tables with 5 best classifiers per criteria ##

```{r results="asis"}
  criteria <- unique(cutted$criteria) # get criteria for filtering
  for (i in 1:length(criteria)) {
    crit <- criteria[i]
    cutted.crit <- cutted[which(cutted$criteria == crit),] # get data for current criteria
    cutted.crit <- arrange(cutted.crit, desc(auc)) # sort data for criteria by auc (descending)
    print(kable(cutted.crit[1:5, c(2, 3, 5, 12, 13, 14, 15)])) # print the firs 5 rows (i.e. 5 best classifier) for criteria
  }
```

## Table with statistical information per criteria and measure information ##

```{r results="asis", echo=FALSE}
  stats <- ddply(cutted, c('criteria_name', 'classifier_name'), summarize, mean = mean(auc), median = median(auc), sd = sd(auc), min = min(auc), max=max(auc))
  print(kable(stats, digits = 3))
```



# Detailed view on selected scenarios #

## Histogram for t=1, n=8, word_accuracy_60 and s = 0.25 ##

Get scenatios with AUC = 1.

```{r}
  # get all performance entries with auc = 1
  p <- cutted[which(cutted$auc == 1),]
    #dbGetQuery(cross_validation, "performance", "{auc: 1}", 0, 0)
```

```{r auc_dot_plots, cache=TRUE, echo=FALSE}
  # loop over the entries and plot the related data from document_results
  for (i in 1:nrow(p)) {
    p_row <- p[i,]
    q <- sprintf("{classifier_name: '%s', frequency_threshold: %d, n_gram_size: %d, criteria: '%s', smoothing_value: %f}",
                 p_row$classifier_name, p_row$frequency_threshold, p_row$n_gram_size, p_row$criteria, p_row$smoothing_value)
    r <- dbGetQuery(cross_validation, "documents_result", q, 0, 0)
    
    title <- sprintf("classifier_name: '%s', frequency_threshold: %d,\n n_gram_size: %d, criteria: '%s', smoothing_value: %.2f",
                 p_row$classifier_name, p_row$frequency_threshold, p_row$n_gram_size, p_row$criteria, p_row$smoothing_value)
    print(ggplot(r, aes(x=positive_class_distance-negative_class_distance, fill=true_class)) +
    geom_dotplot(dotsize = 0.75) + 
    ggtitle(title))
  }
```






